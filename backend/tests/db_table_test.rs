use backend::database::model::*;
use backend::database::table::Table;
use uuid::Uuid;
use rust_decimal::Decimal;

mod common;

// --- Test Harness Macro ---
macro_rules! db_test {
    ($name:ident, |$db:ident| $body:block) => {
        #[tokio::test]
        async fn $name() {
            let ($db, db_name) = common::setup_db().await;
            $body
            common::teardown_db($db, db_name).await;
        }
    };
}

mod institution_table_tests {
    use super::*;

    db_test!(insert_and_select, |db| {
        let institution = Institution {
            id: Uuid::new_v4(),
            name: "Test School".to_string(),
            r#type: "school".to_string(),
            address: Some("123 Test St".to_string()),
            city: Some("Test City".to_string()),
            province: Some("Test Province".to_string()),
            phone: Some("1234567890".to_string()),
            email: Some("test@school.com".to_string()),
            registration_number: Some("REG123".to_string()),
            verified: Some(true),
            created_at: None,
            updated_at: None,
        };

        let id = db.institution_table.insert(&institution).await.expect("Failed to insert institution");
        // assert_eq!(id, institution.id); // ID is generated by DB

        let fetched = db.institution_table.select(&id).await.expect("Failed to select").unwrap();
        assert_eq!(fetched.name, "Test School");
        assert_eq!(fetched.r#type, "school");
    });

    db_test!(update, |db| {
        let institution = Institution {
            id: Uuid::new_v4(),
            name: "Original Name".to_string(),
            r#type: "school".to_string(),
            address: None,
            city: None,
            province: None,
            phone: None,
            email: None,
            registration_number: Some("REG456".to_string()),
            verified: Some(false),
            created_at: None,
            updated_at: None,
        };

        let id = db.institution_table.insert(&institution).await.expect("Failed to insert");
        
        let mut to_update = db.institution_table.select(&id).await.expect("Failed to select").unwrap();
        to_update.name = "Updated Name".to_string();
        
        db.institution_table.update(&to_update).await.expect("Failed to update");

        let fetched = db.institution_table.select(&id).await.expect("Failed to select").unwrap();
        assert_eq!(fetched.name, "Updated Name");
    });

    db_test!(delete, |db| {
        let institution = Institution {
            id: Uuid::new_v4(),
            name: "To Delete".to_string(),
            r#type: "school".to_string(),
            address: None,
            city: None,
            province: None,
            phone: None,
            email: None,
            registration_number: Some("REG789".to_string()),
            verified: Some(false),
            created_at: None,
            updated_at: None,
        };

        let id = db.institution_table.insert(&institution).await.expect("Failed to insert");
        
        db.institution_table.delete(&id).await.expect("Failed to delete");

        let fetched = db.institution_table.select(&id).await.expect("Failed to select");
        assert!(fetched.is_none());
    });
}

mod user_table_tests {
    use super::*;

    db_test!(insert_and_select, |db| {
        let user = User {
            id: Uuid::new_v4(),
            name: "Test User".to_string(),
            role: UserRole::Admin,
            unique_code: "USER123".to_string(),
            phone: Some("08123456789".to_string()),
            verified: Some(true),
            institution_name: None,
            institution_id: None,
            ktp_photo_hash: None,
            last_login: None,
            created_at: None,
            updated_at: None,
        };

        let id = db.user_table.insert(&user).await.expect("Failed to insert user");
        
        let fetched = db.user_table.select(&id).await.expect("Failed to select").unwrap();
        assert_eq!(fetched.name, "Test User");
        assert_eq!(fetched.role, UserRole::Admin);
    });
}

mod kitchen_table_tests {
    use super::*;

    db_test!(insert_and_select, |db| {
        let kitchen = Kitchen {
            id: Uuid::new_v4(),
            name: "Central Kitchen 1".to_string(),
            address: Some("Kitchen Address".to_string()),
            city: Some("Jakarta".to_string()),
            province: Some("DKI Jakarta".to_string()),
            location: None, // Read-only usually
            r#type: Some(KitchenType::CentralKitchen),
            meals_served: Some(1000),
            certifications: None,
            image_url: None,
            owner_id: None,
            created_at: None,
            updated_at: None,
        };

        let id = db.kitchen_table.insert(&kitchen).await.expect("Failed to insert kitchen");
        
        let fetched = db.kitchen_table.select(&id).await.expect("Failed to select").unwrap();
        assert_eq!(fetched.name, "Central Kitchen 1");
        // Note: KitchenType might need PartialEq derived or manual check if it fails
        // assert_eq!(fetched.r#type, Some(KitchenType::CentralKitchen)); 
    });
}

mod compliance_metric_tests {
    use super::*;

    db_test!(insert_and_select, |db| {
        let kitchen_id = Uuid::new_v4(); // In a real test we might want to create a kitchen first, but FK constraints might not be enforced if we don't set them up in the test DB or if we don't care for this unit test
        
        // Create kitchen first to satisfy FK if enforced
        let kitchen = Kitchen {
            id: kitchen_id,
            name: "Kitchen for Metric".to_string(),
            address: None,
            city: None,
            province: None,
            location: None,
            r#type: None,
            meals_served: None,
            certifications: None,
            image_url: None,
            owner_id: None,
            created_at: None,
            updated_at: None,
        };
        let kitchen_id = db.kitchen_table.insert(&kitchen).await.expect("Failed to insert kitchen");

        let metric = ComplianceMetric {
            id: Uuid::new_v4(),
            kitchen_id,
            hygiene_score: Some(Decimal::from_f64_retain(95.5).unwrap()),
            portion_compliance: Some(Decimal::from_f64_retain(98.0).unwrap()),
            nutrition_compliance: Some(Decimal::from_f64_retain(100.0).unwrap()),
            temperature_control: Some(Decimal::from_f64_retain(92.0).unwrap()),
            sla_performance: None,
            last_inspection_date: None,
            trend: Some(ComplianceTrend::Improving),
            created_at: None,
            updated_at: None,
        };

        let id = db.compliance_metric_table.insert(&metric).await.expect("Failed to insert metric");
        
        let fetched = db.compliance_metric_table.select(&id).await.expect("Failed to select").unwrap();
        assert_eq!(fetched.hygiene_score, Some(Decimal::from_f64_retain(95.5).unwrap()));
        assert_eq!(fetched.trend, Some(ComplianceTrend::Improving));
    });
}
